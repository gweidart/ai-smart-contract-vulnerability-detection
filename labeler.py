from patterns import patterns

def label_vulnerabilities(source_code):
    labels = []
    for vulnerability, pattern in patterns.items():
        if pattern.search(source_code):
            labels.append(vulnerability)
    
    # Check for timestamp dependency
    ts_invocation = patterns['TSInvocation'].search(source_code)
    ts_contaminate = patterns['TSContaminate'].search(source_code)
    ts_random = patterns['TSRandom'].search(source_code)
    
    if ts_invocation or (ts_contaminate and ts_random):
        labels.append('timestamp_dependency')
    
    # Check for block number dependency
    bn_invocation = patterns['BNInvocation'].search(source_code)
    bn_contaminate = patterns['BNContaminate'].search(source_code)
    
    if bn_invocation and bn_contaminate:
        labels.append('block_number_dependency')
        
    ed_invocation = patterns['EDInvocation'].search(source_code)
    ed_contaminate = patterns['EDContaminate'].search(source_code)
    
    if ed_invocation and ed_contaminate:
        labels.append('ether_strict_equality_vulnerability')
    
    of_stack_truncate = patterns['OFStackTruncate'].search(source_code)
    safe_math_usage = patterns['SafeMathUsage'].search(source_code)
    
    if of_stack_truncate and not safe_math_usage:
        labels.append('integer_overflow_vulnerability')
    
    external_call = patterns['ExternalCall'].search(source_code)
    exception_consistency = patterns['ExceptionConsistency'].search(source_code)
    return_condition = patterns['ReturnCondition'].search(source_code)
    
    if external_call and exception_consistency and not return_condition:
        labels.append('unchecked_external_call_vulnerability')
    
    dg_invocation = patterns['DGInvocation'].search(source_code)
    fe_transfer = patterns['FETransfer'].search(source_code)
    
    if dg_invocation and not fe_transfer:
        labels.append('ether_frozen_vulnerability')
        
    dg_invocation = patterns['DGInvocation'].search(source_code)
    dg_call_constraint = patterns['DGCallConstraint'].search(source_code)
    dg_parameter = patterns['DGParameter'].search(source_code)
    
    if dg_invocation and not dg_call_constraint and dg_parameter:
        labels.append('delegatecall_vulnerability')
        
    if patterns['CALLValueInvocation'].search(source_code):
        if patterns['RepeatedCallValue'].search(source_code):
            labels.append('reentrancy')
    access_control_violation = patterns['access_control_violation'].search(source_code)
    missing_modifier = patterns['MissingModifier'].search(source_code)
    
    if access_control_violation and missing_modifier:
        labels.append('access_control_violation')
        
    incorrect_storage_initialization = patterns['IncorrectStorageInitialization'].search(source_code)
    constructor_initialization = patterns['ConstructorInitialization'].search(source_code)
    
    if incorrect_storage_initialization and not constructor_initialization:
        labels.append('incorrect_storage_initialization')
    ddos_vulnerability = patterns['DDoSVulnerability'].search(source_code)
    gas_limit_check = patterns['GasLimitCheck'].search(source_code)
    external_call_in_loop = patterns['ExternalCallInLoop'].search(source_code)
    
    if ddos_vulnerability and not gas_limit_check and external_call_in_loop:
        labels.append('ddos_vulnerability')
        
    transaction_ordering_dependence = patterns['TransactionOrderingDependence'].search(source_code)
    randomness_source = patterns['RandomnessSource'].search(source_code)
    
    if transaction_ordering_dependence and randomness_source:
        labels.append('transaction_ordering_dependence')
    lack_of_randomness = patterns['LackOfRandomness'].search(source_code)
    secure_randomness = patterns['SecureRandomness'].search(source_code)
    
    if lack_of_randomness and not secure_randomness:
        labels.append('lack_of_randomness')
        
    erc20_api_violation = patterns['ERC20APIViolation'].search(source_code)
    event_emission = patterns['EventEmission'].search(source_code)
    
    if erc20_api_violation and not event_emission:
        labels.append('erc20_api_violation')
        
    signatures_replay = patterns['SignaturesReplay'].search(source_code)
    nonce_usage = patterns['NonceUsage'].search(source_code)
    signature_verification = patterns['SignatureVerification'].search(source_code)
    
    if signatures_replay and not nonce_usage and not signature_verification:
        labels.append('signatures_replay')
    
    return labels
